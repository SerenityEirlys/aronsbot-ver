import { SlashCommandBuilder } from 'discord.js';
import { EmbedBuilder } from 'discord.js';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import crypto from 'crypto';
import { pool } from '../../db/mysql.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default {
    data: new SlashCommandBuilder()
        .setName('genhwid')
        .setDescription('Generate HWIDs and store them in database')
        .addIntegerOption(option =>
            option.setName('amount')
                .setDescription('Number of HWIDs to generate (1-100)')
                .setRequired(true)
                .setMinValue(1)
                .setMaxValue(100)),

    async execute(interaction) {
        try {
            // Check if user is a reseller
            const resellerId = interaction.user.id;
            const resellerPath = path.join(__dirname, '../../data/roblox/reseller.txt');
            
            if (!fs.existsSync(resellerPath)) {
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå System Error')
                    .setDescription('Reseller file not found. Please contact an administrator.')
                    .setColor(0xFF0000);
                return await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }

            const resellerContent = fs.readFileSync(resellerPath, 'utf8');
            const resellerIds = resellerContent.split('\n').map(line => line.trim());

            if (!resellerIds.includes(resellerId)) {
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Permission Denied')
                    .setDescription('This command is only available for resellers.')
                    .setColor(0xFF0000);
                return await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }

            await interaction.deferReply({ ephemeral: true });

            const amount = interaction.options.getInteger('amount');

            // Generate HWIDs
            const generatedHWIDs = [];
            for (let i = 0; i < amount; i++) {
                const hwid = await this.generateHWID();
                generatedHWIDs.push(hwid);
            }

            // Save to MongoDB
            const hwidDocuments = generatedHWIDs.map(hwid => ({
                hwid: hwid,
                isUsed: false
            }));

            await HWID.insertMany(hwidDocuments);

            // Ensure directory exists
            const hwidDir = path.join(__dirname, '../../data/shop');
            if (!fs.existsSync(hwidDir)) {
                fs.mkdirSync(hwidDir, { recursive: true });
            }

            // Save to file
            const hwidPath = path.join(hwidDir, 'hwid.txt');
            const timestamp = new Date().toISOString();
            const hwidContent = generatedHWIDs.map(hwid => 
                `${hwid} | Generated: ${timestamp} | By: ${interaction.user.tag}`
            ).join('\n') + '\n';

            fs.appendFileSync(hwidPath, hwidContent);

            // Create text file attachment
            const tempFilePath = path.join(hwidDir, `hwid_temp_${Date.now()}.txt`);
            fs.writeFileSync(tempFilePath, generatedHWIDs.join('\n'));

            // Create success embed
            const successEmbed = new EmbedBuilder()
                .setTitle('‚úÖ HWIDs Generated Successfully')
                .setDescription(`Generated ${amount} new HWIDs`)
                .addFields(
                    { name: 'Total Generated', value: amount.toString() },
                    { name: 'Generated By', value: interaction.user.tag }
                )
                .setColor(0x00FF00)
                .setTimestamp();

            // Send response with file attachment
            await interaction.editReply({
                embeds: [successEmbed],
                files: [{
                    attachment: tempFilePath,
                    name: 'generated_hwids.txt'
                }]
            });

            // Clean up temporary file
            fs.unlinkSync(tempFilePath);

            // Send first few HWIDs as preview in ephemeral message
            const previewHWIDs = generatedHWIDs.slice(0, 5);
            const previewEmbed = new EmbedBuilder()
                .setTitle('üîë HWID Preview')
                .setDescription('Here are the first 5 HWIDs generated:')
                .addFields(
                    previewHWIDs.map((hwid, index) => ({
                        name: `HWID #${index + 1}`,
                        value: `\`${hwid}\``
                    }))
                )
                .setFooter({ text: 'Full list has been saved and attached above' })
                .setColor(0x00FF00);

            await interaction.followUp({ embeds: [previewEmbed], ephemeral: true });

        } catch (error) {
            console.error('Error in genhwid command:', error);
            const errorEmbed = new EmbedBuilder()
                .setTitle('‚ùå Error')
                .setDescription('An error occurred while generating HWIDs. Please try again.')
                .setColor(0xFF0000);
            
            if (!interaction.deferred) {
                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            } else {
                await interaction.editReply({ embeds: [errorEmbed] });
            }
        }
    },

    async generateHWID() {
        const hwid = crypto.randomUUID();
        await pool.execute(
            'INSERT INTO hwids (hwid) VALUES (?)',
            [hwid]
        );
        return hwid;
    }
}; 